\documentclass[conference]{IEEEtran}
%\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{algorithmic}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{braket}
\usepackage{cite}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{pgfplots}
\pgfplotsset{width=7cm,compat=1.8}
\usepackage{textcomp}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Simulating Attacks on Authenticated Semi-Quantum Direct Communication Protocol}

\author{\IEEEauthorblockN{Nathan Marshall}
\IEEEauthorblockA{
Ottawa, Canada \\
nathsmar@gmail.com}
\and
\IEEEauthorblockN{Nick Rivard}
\IEEEauthorblockA{
Ottawa, Canada \\
nhrivard@gmail.com}
}

\maketitle

\begin{abstract}

This study presents a detailed analysis of the randomization-based authenticated semi-quantum direct
communication protocol presented by Yi-Ping Luo and Tzonelih Hwang, as well as several of the attacks
already examined in their analysis of the protocol. The protocol uses pre-shared keys
rather than a classical channel, and requires only the sender to have advanced quantum capabilities.
We have implemented a simulation of the protocol and confirmed that it is resistent to impersonation
attacks, intercept-and-resend attacks, and one-qubit modification attacks. We have also solved
the problem of reordering qubits into a random permutation based on a key,
which was not explained in the original description of the protocol.

\end{abstract}

\begin{IEEEkeywords}

Authentication,
Authenticated semi-quantum communication,
Bell states,
Quantum communication,
Quantum cryptography,
Semi-quantum communication

\end{IEEEkeywords}

\section{Introduction}

While practical quantum communication is feasible using
modern technology, the cost of nodes capable of quantum computation
will likely remain high for some time. Since simpler, "classical" nodes
(with only the ability to read individual qubits) are cheaper,
semi-quantum communication protocols are useful for practical,
cost-efficient, secure communication.

This work is based on an authenticated semi-quantum direct communication (ASQDC) protocol
proposed by Yi-Ping Luo and Tzonelih Hwang that takes advantage of this idea
of a "classical" receiver Bob \cite{LuoHwang}.
The present work describes their article and the insights,
results, and conclusions gained from implementing the randomization-based version
of the ASQDC protcol described therein.

We implemented a simulation of the aforementioned protocol in Matlab
using Quantum Information Toolkit (QIT), which brought to light parts of the
protocol that were not defined thoroughly enough to trivially follow.
Our contributions are a useful reference for implementing a real ASQDC
network, since the challenges we encountered in reordering qubits based
on a shared key would inevitably be encountered by others as well.

We successfully implemented the randomization-based ASQDC
protocol as per the specifications laid out in their article,
and also generated data concerning the security of the protocol
in the presence of four attacks: impersonation of Alice, impersonation
of Bob, intercept-and-resend attack, and modification of 1-qubit attack.
We slightly modified the definition of the intercept-and-resend attack
from the description given by Luo and Hwang, and we disagreed slightly on the
security analysis for the impersonation of Bob. Nevertheless, our
results support the claim that the protocol is secure against these
attacks, except for impersonating Alice with small message size.

\section{Problem Domain}

\subsection{Authentication}

Message authentication is the process of confirming the origin and
data integrity of a given message. This means confirming both that the
message did in fact originate from a given sender and that the message
was not modified during transit. This is often done using a combination of
shared secrets (keys) and cryptographic hash functions. If the message
can only be transformed into its corresponding plaintext by a particular key
which corresponds to a key which is only in the possession
of a known sender, then one can infer that the message must have been
sent by the known sender since it must have been encrypted using that
key. Similarly for data integrity, if a given plaintext is input
into a one-way function (a cryptographic hash function) and produces
the observed hash value, then it can be inferred that it is the same
message that was originally used by the known sender to produce the
hash before they encrypted the message. In reality there
can be many complications to the above, but this model is sufficient
for the present discussion.

\subsection{Requirements for Authentication in Traditional Protocols}

Typically, quantum communications protocols implement message
authentication indirectly using authenticated classical (non-quantum)
channels and nodes which are capable of performing quantum computation.
These restraints limit the viable use-cases for message authentication
in quantum communications. Firstly, a dedicated and highly available
authenticated classical channel might not be feasible in nodes which are
powered by battery. Secondly, while quantum computers exist now, they tend
to be expensive and sensitive to environmental conditions, so it would be very
challenging to build and deploy reliable mobile quantum computers.

\subsection{Authenticated Semi-Quantum Key Distribution}

Before ASQDC protocols were designed, Yu et al. proposed Authenticated
Semi-Quantum Key Distribution (ASQKD) protocols \cite{YuEtAl}, which also
require only the sender to have full quantum capabilities. In these protocols,
in order to circumvent the need for an authenticated classical channel,
keys are shared between sender and receiver in advance. The receiver Bob is
considered a classical Bob because it only needs
to be able to perform the following operations: (1) prepare qubits
in the classical basis $\left\{ \ket{0} ,\ket{1} \right\} $,
(2) measure individual qubits in the the classical basis, (3) permute
qubits, and (4) reflect qubits without measuring them. The sender Alice needs
to perform the following operations: (1) prepare any arbitrary quantum states and
(2) perform arbitrary quantum measurement.

\subsection{ASQDC and Bell States}

Building upon the work of Yu et. al. on ASQKD, Luo and Hwang introduced the first
ASQDC protocols, which make use of Bell states to prevent information leakage,
enabling Alice to determine if a malicious actor Eve extracted
information from the transmission.

Bell states are the four maximally-entangled states that can be produced
using two qubits. When the state of one qubit is measured (reduced
to a classical bit), the state of the other qubit is instantly known
by the party who measured the first. If, for example, two photons (qubits)
are entangled into a Bell state and one of the photons is sent to
another location, the sender will instantly know the value of the
transmitted photon when they measure the remaining photon. 

\subsection{Cases Implemented}

We consider five cases: no attacker, Eve impersonating Alice, Eve
impersonating Bob, Eve intercepting and resending the message, and Eve
modifying one qubit of the message.

\subsubsection{No Attacker}

In the case where there is no attacker, the protocol is expected
to function every time, because our simulation does not take environmental
factors into account.

Given a classical message $m$ of length $\frac{n}{8}$, Alice computes
the hash $h(m)$ of $m$ and concatenates $m$ with $h(m)$ to produce $M=m||h(m)$ where
$||$ denotes concatenation. The constraints
on the hash function $h$ are that it must output a hash equal in
length to the message and that it must never produce collisions. Given
these constraints, we opted to simply flip the value of each
bit from the message in the hash. While this is not an ideal, secure hash function,
our simulation is very cpu-intensive and memory intensive when dealing with an $m$ larger
than 2 bits, so Eve will only be brute-forcing the keys in this simulation.
Our hash function does ensure that the protocol can be used to send any
length of message without hash collisions.
With longer messages, a more standard, secure hash function should be used, and a fixed message length
should be used, which is equal to the number of bits output by that hash function.

Next, Alice produces a sequence of Bell-EPR pairs $S$ such that if $M[i]$=0 then $S[i]=\ket{\phi^{+}} $.
Otherwise, $S[i]=\ket{\psi^{-}} $. Alice then generates
a check state: a random sequence of Bell-EPR pairs $C$ in the basis $\left\{ \ket{\phi^{+}} ,\ket{\psi^{-}} \right\} $
with the same length as $S$. The individual qubits of each of the Bell-EPR pairs within $C$ are reordered such that
the first qubit from each pair is ordered in sequence $C_{a}$ preceded by the sequence $C_{b}$ of each second
qubit from each pair.

Alice shuffles the qubits in the tensor product of $S$ and $C_{b}$,
based on $K_{1}$ which is a {\LARGE\color{red}Lehmer code} that represents a random permutation of $\frac{3n}{4}$ elements.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% CITE!!!!!!!!!!!!!!!!!!!!!!!
We call the resulting shuffled sequence $Q$. $Q$ is sent to Bob, while Alice retains $C_{a}$,
which will be used later to verify that Bob successfully received the message. In out QIT implementation,
$C_{a}$ appears to be included in $Q$, but this is only because we were unaware of a way to separate the states
using QIT. Bob never measures nor modifies the qubits in $C_{a}$, and they should be considered to have never been sent.

Upon receiving $SC_{b}$, Bob reorders $S^{\prime}C_{b}^{\prime}$
using $K_{1}^{-1}$ which denotes the Lehmer code representing the inverse permutation of that represented by $K_{1}$.
Bob then performs a Z-basis measurement on $S^{\prime}$,
obtaining the measurement result $MR_{b}$, from which Bob retrieves
the message and hash $M^{\prime}=m^{\prime}||h\left(m\right)^{\prime}$.
Bob then computes $h\left(m^{\prime}\right)$ and compares it to $h\left(m\right)^{\prime}$
and, if they are not equal, Bob terminates the protocol.

If $h\left(m^{\prime}\right)=h\left(m\right)^{\prime}$, Bob shuffles
$C_{b}^{\prime}$ using Lehmer code $K_{2}$ and reflects the result, $C_{b}^{\prime\prime}$
back to Alice.

Alice then applies $K_{2}^{-1}$, the Lehmer code representing the inverse
of the permutation given by $K_{2}$, to reorder $C_{b}^{\prime\prime}$, obtaining
$C_{b}^{\prime\prime\prime}$. The qubits from $C_{b}^{\prime\prime\prime}$ are reordered
with the qubits from $C_{a}$ to form a sequence $C^{\prime}$ of pairs, which is expected to be the
original check state $C$. Alice performs Bell-EPR measurement on $C^{\prime}$, and if the result
is equal to the original bit sequence that was used to generate the Bell-EPR pairs of $C$,
then Alice believes that the protocol succeeded and that the message was not compromised.

\subsubsection{Impersonating Alice}

In this attack, Eve pretends to be Alice by sending a forged message to Bob.
We assume that Eve implements the exact procedures that Alice
would under ordinary circumstances, including Bell-EPR
measurement and the same hash function. The only difference is that Eve
does not know $K_{1}$ nor $K_{2}^{-1}$, and must guess, shuffling the
qubits arbitraily. Eve does not know whether the reflected check qubits $C_{b}$
are correct, but expects $\frac{n}{4}$ qubits to be reflected from Bob.

\subsubsection{Impersonating Bob}

In this attack, Eve pretends to be Bob by intercepting a message sent from Alice that was
intended for Bob. Eve does not know $K_{1}^{-1}$ nor $K_{2}$, and must guess, shuffling the
qubits arbitraily. This means that Eve does not know if the received message $m^{\prime}$ is correct, even
if $h(m^{\prime}) = h(m)^{\prime}$. While our implementation behaves very similarly to Bob
under ordinary circumstances, Eve does not need to implement Z-basis measurement at all, and only needs
to reflect the check qubits $C_{b}^{\prime}$ back in an arbitrary order.

\subsubsection{Intercept-and-Resend Attack}

In our definition of the intercept-and-resend attack, Eve can be considred to
be impersonating both Bob and Alice. 
Eve first impersonates Bob when communicating with Alice, then impersonates
Alice while communicating with Bob, essentially conducting a man-in-the-middle (MITM) attack.
This differs from the intercept-and-resend attack described by Luo and Hwang, in which Eve measures $Q$
on the way from Alice to Bob and $C_{b}$ on the way from Bob to Alice, collapses the quantum
states and destroying the entanglement of the Bell-EPR pairs.

In our definition of the attack, Eve must guess $K_{1}$, $K_{1}^{-1}$, $K_{2}$, and $K_{2}^{-1}$.
The intention of this attack is for Eve to determine the content of $m$ by measuring what
she receives from Alice. However, Eve cannot guarantee that the received message is correct, since
she does not know if her key $K_{1}^{-1}$ is correct, so the gathered information is of no use.

\subsubsection{1-Qubit Modification Attack}

In this attack, Eve performs a MITM attack, but
rather than reordering and measuring the message to determine its content,
she modifies one qubit in $Q$ as received from Alice, and then sends the result to Bob.

\section{Simulation of Protocol with and without Attacks}

\subsection{Summary}

The results of our simulation mostly reflected the predictions of Luo and Hwang,
though our calculated detection probability for impersonation of Bob differed from theirs.
The empirical results are not stable enough to conclude with certainty which of the formulas is correct.

The protocol always worked in the absence of an attacker, and Eve was always detected
in a 1-qubit modification attack. The other attacks were detected with very high probability,
except for the impersonation of Alice, since our message length was quite small ($n=16$, $|m|=2$).

\subsection{Security Analysis}

\subsubsection{Impersonating Alice Attack}

Since Eve does not know the key $K_{1}$, she must guess it. If $K_{1}$
is $n$ bits long, then the probability of Eve guessing the correct
key is $\frac{n}{2^{n}}$. In the event that she does guess $K_{1}$
correctly, she will successfully impersonate Alice, thus fooling Bob.
In the present work, the length of the key used during simulation
was $n=12$, resulting in a probability $\frac{12}{2^{12}}=\frac{3}{1024}$
that Eve correctly guessed the key. 

In order to successfully impersonate Alice, Eve must deliver to Bob
a message $m_{e}$ and a hash $h\left(m_{e}\right)_{e}$ such that
$h\left(m_{e}\right)=h\left(m_{e}\right)_{e}$. Because $h\left(m_{e}\right)$
is $2$ Bell pairs in length, and there is a $\frac{1}{2}$ probability
that each Bell pair is comprised of two equal qubits and a $\frac{1}{2}$
probability that each Bell pair is comprised of two unequal qubits
(note: where the qubits came from isn't actually what is important).
Thus, the total probability that $h\left(m_{e}\right)=h\left(m_{e}\right)_{e}$
is $\left(\frac{1}{2}\right)^{\frac{n}{8}}=\frac{1}{4}$ and the probability
that Eve is detected is $1-\frac{1}{4}=\frac{3}{4}$. This corresponds
to the data collected via the simulation.

\subsubsection{Impersonating Bob Attack}

In order to successfully impersonate Bob, Eve must deliver to Alice
a $C_{b_{e}}$ such that $C_{b_{e}a}=C_{ba}$. Because either value
is comprised of $4$ qubits (half of each in $C_{b_{e}}$ and half
of each in $C_{a}$, and because the corresponding Bell pairs each
have a $\frac{1}{4}$ probability of turning out correctly. Therefore,
the probability that $C_{b_{e}a}=C_{ba}$ is $ $

\subsubsection{Intercept and Resend Attack}

\subsubsection{1-Qubit Modification Attack}

In this case, Eve cannot successfully modify a single qubit without
being detected because either she will modify a single qubit in $m$
(in which case $h\left(m_{e}\right)\neq h\left(m_{e}\right)_{e}$),
or she will modify a single qubit in $h\left(m\right)$ (in which
case, again, $h\left(m_{e}\right)\neq h\left(m\right)$), or else
she will modify a single qubit in $C_{b}$ (in which case, 

\section{Evaluation}

The measured results do support the claims of the randomized-ASQDC
protocol. The implementation tested in the current work behaved as
expected in the face of five attacker cases: no attacker, impersonation
of Alice, impersonation of Bob, intercept-and-resend attack, and 1-qubit
modification attack. 

\pgfplotstableread[row sep=\\,col sep=&]{
    outcome                                 & Expected & Result \\
    No Attacker: Success                    &    10000 &  10000 \\
    Impersonate Alice: Detected             &     7500 &   7464 \\
    Impersonate Bob: Detected               &     9961 &   9891 \\
    Intercept-and-resend: Detected by Bob   &     7500 &   7441 \\
    Intercept-and-resend: Detected by Alice &     9961 &   9954 \\
    Intercept-and-resend: Detected          &     9990 &   9985 \\
    1-Qubit Modification: Detected by Bob   &     6667 &   6678 \\
    1-Qubit Modification: Detected by Alice &     3333 &   3322 \\
    1-Qubit Modification: Detected          &    10000 &  10000 \\
}\mydata

\begin{figure}
    \vspace{1em}
    \caption{Expected vs. simulated results after 10,000 simulations with $n=16$}
    \label{fig:resultsGraph}
    \vspace{1em}
    \begin{tikzpicture}
        \begin{axis}
            [
                xbar,
                ylabel = {Outcome},
                xlabel = {\# occurrences},
                xlabel style = {
                    yshift = 1em,
                },
                bar shift = {-0.4*(\numplotsofactualtype*\pgfplotbarwidth + (\numplotsofactualtype-1)*(2pt)) - (.5+\plotnumofactualtype)*\pgfplotbarwidth - \plotnumofactualtype*(2pt)},
                symbolic y coords = {
                    No Attacker: Success,
                    Impersonate Alice: Detected,
                    Impersonate Bob: Detected,
                    Intercept-and-resend: Detected by Bob,
                    Intercept-and-resend: Detected by Alice,
                    Intercept-and-resend: Detected,
                    1-Qubit Modification: Detected by Bob,
                    1-Qubit Modification: Detected by Alice,
                    1-Qubit Modification: Detected,
                },
                tick label style = {
                    font = \small,
                },
                y tick label style = {
                    anchor = west,
                    xshift = 0.1cm,
                    yshift = 0,
                },
                y dir = reverse,
                xtick = {0, 10000},
                scaled x ticks = false,
                ytick = data,
                xmin = 0,
                xmax = 10000,
                nodes near coords,
                bar width = .3cm,
                height = 15cm,
                width = 8cm,
                legend style = {
                    at={(0.5, 1)},
                    anchor = north,
                    legend columns = -1,
                },
            ]
            \addplot table[y=outcome, x=Expected]{\mydata};
            \addplot table[y=outcome, x=Result]{\mydata};
            \legend{Expected\,\,\,\,, Result}
        \end{axis}
    \end{tikzpicture}
\end{figure}

\section{Conclusion}

In summary, the current work tested a Matlab with QIT implementation
of the randomization-based ASQDC protocol in five sets of circumstances:
no attacker, impersonation of Alice, impersonation of Bob, intercept-and-resend
attack, and 1-qubit modification attack. The measured results were
then compared against the theoretical values, supporting the claims
of the ASQDC protocol authors.

This is relevant to quantum communications research as such a protocol
may be more feasible than fully-quantum protocols in a variety of
circumstances in the short-to-medium term. Furthermore, it was shown
that the protocol is, in fact, secure against four major categories
of attack.

Future work would include testing the protocol against additional
attacks, such as n-qubit modification attacks. It would also be of
benefit to test the protocol on computers which are capable of handling
larger values of $n$ (longer messages) in order to demonstrate empirically
that the security does in fact scale with message length as predicted
by theory.

\begin{thebibliography}{00}
\bibitem{LuoHwang} Y.-P. Luo, T. Hwang, ``Authenticated semi-quantum direct communication protocols using Bell states,'' Quantum Information Processing, vol. 15, no. 2, pp. 957--958, 2015.
\bibitem{YuEtAl} K. Yu, C.-W. Yang, C.-H. Liao, T. Hwang, ``Authenticated semi-quantum key distribution protocol using Bell states,'' Quantum Information Processing, vol. 13, no. 6, pp. 1457--1565, 2014.
\end{thebibliography}
\vspace{12pt}

\appendix
\section{Matlab Code}
All Matlab code for the project is attached below. The {\ttfamily Execute.m} script was used to generate the simulated results in Fig. \ref{fig:resultsGraph}.
{\ttfamily numExecutions} on line 5 is the number of simulations to run for each type of attack, which can be modified from 10,000.

\onecolumn
\definecolor{MatlabComment}{rgb}{0, 0.6, 0}
\lstset {
    language=Matlab,
    frame=single,
    breaklines=true,
    showstringspaces=false,
    numbers=left,
    basicstyle=\footnotesize\ttfamily,
    commentstyle=\color{MatlabComment},
    keywordstyle=\color{blue},
    stringstyle=\color{magenta},
}
\lstinputlisting[title=Alice.m]{"../Alice.m"}
\lstinputlisting[title=Bob.m]{"../Bob.m"}
\lstinputlisting[title=Eve.m]{"../Eve.m"}
\lstinputlisting[title=Execute.m]{"../Execute.m"}
\lstinputlisting[title=helper.m]{"../helper.m"}
\lstinputlisting[title=utilities.m]{"../utilities.m"}

\end{document}
