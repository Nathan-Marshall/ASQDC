\documentclass[conference]{IEEEtran}
%\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{algorithmic}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{braket}
\usepackage{cite}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{pgfplots}
\pgfplotsset{width=7cm,compat=1.8}
\usepackage{textcomp}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Simulating Attacks on Authenticated Semi-Quantum Direct Communication Protocol}

\author{\IEEEauthorblockN{Nathan Marshall}
\IEEEauthorblockA{
Ottawa, Canada \\
nathsmar@gmail.com}
\and
\IEEEauthorblockN{Nick Rivard}
\IEEEauthorblockA{
Ottawa, Canada \\
nhrivard@gmail.com}
}

\maketitle

\begin{abstract}

This study presents a detailed analysis of the randomization-based authenticated semi-quantum direct
communication protocol presented by Yi-Ping Luo and Tzonelih Hwang, as well as several of the attacks
already examined in their analysis of the protocol. The protocol uses pre-shared keys
rather than a classical channel, and requires only the sender to have advanced quantum capabilities.
We have implemented a simulation of the protocol and confirmed that it is resistent to impersonation
attacks, intercept-and-resend attacks, and one-qubit modification attacks. We have also solved
the problem of reordering qubits into a random permutation based on a key,
which was not explained in the original description of the protocol.

\end{abstract}

\begin{IEEEkeywords}

Authentication,
Authenticated semi-quantum communication,
Bell states,
Quantum communication,
Quantum cryptography,
Semi-quantum communication

\end{IEEEkeywords}

\section{Introduction}

While practical quantum communication is feasible using
modern technology, the cost of nodes capable of quantum computation
will likely remain high for some time. Since simpler, "classical" nodes
(with only the ability to read individual qubits) are cheaper,
semi-quantum communication protocols are useful for practical,
cost-efficient, secure communication.

This work is based on an authenticated semi-quantum direct communication (ASQDC) protocol
proposed by Yi-Ping Luo and Tzonelih Hwang that takes advantage of this idea
of a "classical" receiver Bob \cite{LuoHwang}.
The present work describes their article and the insights,
results, and conclusions gained from implementing the randomization-based version
of the ASQDC protcol described therein.

We implemented a simulation of the aforementioned protocol in Matlab
using Quantum Information Toolkit (QIT), which brought to light parts of the
protocol that were not defined thoroughly enough to trivially follow.
Our contributions are a useful reference for implementing a real ASQDC
network, since the challenges we encountered in reordering qubits based
on a shared key would inevitably be encountered by others as well.

We successfully implemented the randomization-based ASQDC
protocol as per the specifications laid out in their article,
and also generated data concerning the security of the protocol
in the presence of four attacks: impersonation of Alice, impersonation
of Bob, intercept-and-resend attack, and modification of 1-qubit attack.
We slightly modified the definition of the intercept-and-resend attack
from the description given by Luo and Hwang, and we disagreed slightly on the
security analysis for the impersonation of Bob. Nevertheless, our
results support the claim that the protocol is secure against these
attacks, except for impersonating Alice with small message size.

\section{Problem Domain}

\subsection{Authentication}

Message authentication is the process of confirming the origin and
data integrity of a given message. This means confirming both that the
message did in fact originate from a given sender and that the message
was not modified during transit. This is often done using a combination of
shared secrets (keys) and cryptographic hash functions. If the message
can only be transformed into its corresponding plaintext by a particular key
which corresponds to a key which is only in the possession
of a known sender, then one can infer that the message must have been
sent by the known sender since it must have been encrypted using that
key. Similarly for data integrity, if a given plaintext is input
into a one-way function (a cryptographic hash function) and produces
the observed hash value, then it can be inferred that it is the same
message that was originally used by the known sender to produce the
hash before they encrypted the message. In reality there
can be many complications to the above, but this model is sufficient
for the present discussion.

\subsection{Requirements for Authentication in Traditional Protocols}

Typically, quantum communications protocols implement message
authentication indirectly using authenticated classical (non-quantum)
channels and nodes which are capable of performing quantum computation.
These restraints limit the viable use-cases for message authentication
in quantum communications. Firstly, a dedicated and highly available
authenticated classical channel might not be feasible in nodes which are
powered by battery. Secondly, while quantum computers exist now, they tend
to be expensive and sensitive to environmental conditions, so it would be very
challenging to build and deploy reliable mobile quantum computers.

\subsection{Authenticated Semi-Quantum Key Distribution}

Before ASQDC protocols were designed, Yu et al. proposed Authenticated
Semi-Quantum Key Distribution (ASQKD) protocols \cite{YuEtAl}, which also
require only the sender to have full quantum capabilities. In these protocols,
in order to circumvent the need for an authenticated classical channel,
keys are shared between sender and receiver in advance. The receiver Bob is
considered a classical Bob because it only needs
to be able to perform the following operations: (1) prepare qubits
in the classical basis $\left\{ \ket{0} ,\ket{1} \right\} $,
(2) measure individual qubits in the the classical basis, (3) permute
qubits, and (4) reflect qubits without measuring them. The sender Alice needs
to perform the following operations: (1) prepare any arbitrary quantum states and
(2) perform arbitrary quantum measurement.

\subsection{ASQDC and Bell States}

Building upon the work of Yu et. al. on ASQKD, Luo and Hwang introduced the first
ASQDC protocols, which make use of Bell states to prevent information leakage,
enabling Alice to determine if a malicious actor Eve extracted
information from the transmission.

Bell states are the four maximally-entangled states that can be produced
using two qubits. When the state of one qubit is measured (reduced
to a classical bit), the state of the other qubit is instantly known
by the party who measured the first. If, for example, two photons (qubits)
are entangled into a Bell state and one of the photons is sent to
another location, the sender will instantly know the value of the
transmitted photon when they measure the remaining photon. 

\subsection{Cases Implemented}

We consider five cases: no attacker, Eve impersonating Alice, Eve
impersonating Bob, Eve intercepting and resending the message, and Eve
modifying one qubit of the message.

\subsubsection{No Attacker}

In the case where there is no attacker, the protocol is expected
to function every time, because our simulation does not take environmental
factors into account.

Given a classical message $m$ of length $\frac{n}{8}$, Alice computes
the hash $h(m)$ of $m$ and concatenates $m$ with $h(m)$ to produce $M=m||h(m)$ where
$||$ denotes concatenation. The constraints
on the hash function $h$ are that it must output a hash equal in
length to the message and that it must never produce collisions. Given
these constraints, we opted to simply flip the value of each
bit from the message in the hash. While this is not an ideal, secure hash function,
our simulation is very cpu-intensive and memory intensive when dealing with an $m$ larger
than 2 bits, so Eve will only be brute-forcing the keys in this simulation.
Our hash function does ensure that the protocol can be used to send any
length of message without hash collisions.
With longer messages, a more standard, secure hash function should be used, and a fixed message length
should be used, which is equal to the number of bits output by that hash function.

Next, Alice produces a sequence of Bell-EPR pairs $S$ such that if $M[i]$=0 then $S[i]=\ket{\phi^{+}} $.
Otherwise, $S[i]=\ket{\psi^{-}} $. Alice then generates
a check state: a random sequence of Bell-EPR pairs $C$ in the basis $\left\{ \ket{\phi^{+}} ,\ket{\psi^{-}} \right\} $
with the same length as $S$. The individual qubits of each of the Bell-EPR pairs within $C$ are reordered such that
the first qubit from each pair is ordered in sequence $C_{a}$ preceded by the sequence $C_{b}$ of each second
qubit from each pair.

Alice shuffles the qubits in the tensor product of $S$ and $C_{b}$,
based on $K_{1}$ which is a {\LARGE\color{red}Lehmer code} that represents a random permutation of $\frac{3n}{4}$ elements.%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% CITE!!!!!!!!!!!!!!!!!!!!!!!
We call the resulting shuffled sequence $Q$. $Q$ is sent to Bob, while Alice retains $C_{a}$,
which will be used later to verify that Bob successfully received the message. In out QIT implementation,
$C_{a}$ appears to be included in $Q$, but this is only because we were unaware of a way to separate the states
using QIT. Bob never measures nor modifies the qubits in $C_{a}$, and they should be considered to have never been sent.

Upon receiving $SC_{b}$, Bob reorders $S^{\prime}C_{b}^{\prime}$
using $K_{1}^{-1}$ which denotes the Lehmer code representing the inverse permutation of that represented by $K_{1}$.
Bob then performs a Z-basis measurement on $S^{\prime}$,
obtaining the measurement result $MR_{b}$, from which Bob retrieves
the message and hash $M^{\prime}=m^{\prime}||h\left(m\right)^{\prime}$.
Bob then computes $h\left(m^{\prime}\right)$ and compares it to $h\left(m\right)^{\prime}$
and, if they are not equal, Bob terminates the protocol.

If $h\left(m^{\prime}\right)=h\left(m\right)^{\prime}$, Bob shuffles
$C_{b}^{\prime}$ using Lehmer code $K_{2}$ and reflects the result, $C_{b}^{\prime\prime}$
back to Alice.

Alice then applies $K_{2}^{-1}$, the Lehmer code representing the inverse
of the permutation given by $K_{2}$, to reorder $C_{b}^{\prime\prime}$, obtaining
$C_{b}^{\prime\prime\prime}$. The qubits from $C_{b}^{\prime\prime\prime}$ are reordered
with the qubits from $C_{a}$ to form a sequence $C^{\prime}$ of pairs, which is expected to be the
original check state $C$. Alice performs Bell-EPR measurement on $C^{\prime}$, and if the result
is equal to the original bit sequence that was used to generate the Bell-EPR pairs of $C$,
then Alice believes that the protocol succeeded and that the message was not compromised.

\subsubsection{Impersonating Alice}

Eve can communicate with Bob, pretending to be Alice, by simply taking
on the role of Alice in the protocol described above, using Eve has
the requisite quantum computing capabilities described above. The
only difference is that Eve needs to guess which keys $K_{1},K_{2}$
to use.

\subsubsection{Impersonating Bob}

Likewise, Eve can impersonate Bob by receiving the message from Alice
and using the part of the protocol normally used by Bob. As above,
Eve will need to guess the keys $K_{1},K_{2}$.

\subsubsection{Intercept-and-Resend Attack}

In this attack, Eve first impersonates Bob to Alice and then imperonsates
Alice to Bob, essentially conducting a MITM attack. The point of this
attack, from Eve's perspective, is to determine the content of the
message by measuring what she receives from Alice. Again, as above,
Eve must guess the keys $K_{1},K_{2}$.

\subsubsection{1-Qubit Modification Attack}

In this attack, Eve performs a MITM attack, similar to above, but
rather than measuring the message to determine its content, she modifies
one of the qubits and then sends the resulting message to Bob.

\section{Simulation of Protocol with and without Attacks}

\subsection{Summary}

The results achieved mostly reflected the predictions of the creators
of the protocol. The protocol always worked in the absence of an attacker,
as expected. In the cases involving Eve either impersonating Alice
or Bob, the protocol could execute successfully only in the cases
where Eve guesses both keys correctly, or where both keys are wrong
but in such a way that in combination they right each other.

\subsection{Security Analysis}

\subsubsection{Impersonating Alice Attack}

Since Eve does not know the key $K_{1}$, she must guess it. If $K_{1}$
is $n$ bits long, then the probability of Eve guessing the correct
key is $\frac{n}{2^{n}}$. In the event that she does guess $K_{1}$
correctly, she will successfully impersonate Alice, thus fooling Bob.
In the present work, the length of the key used during simulation
was $n=12$, resulting in a probability $\frac{12}{2^{12}}=\frac{3}{1024}$
that Eve correctly guessed the key. 

\subsubsection{Impersonating Bob Attack}

Since Eve does not know the key 

\subsubsection{Intercept and Resend Attack}

\subsubsection{1-Qubit Modification Attack}

\section{Evaluation}

The measured results do support the claims of the randomized-ASQDC
protocol. The implementation tested in the current work behaved as
expected in the face of five attacker cases: no attacker, impersonation
of Alice, impersonation of Bob, intercept-and-resend attack, and 1-qubit
modification attack. 

\pgfplotstableread[row sep=\\,col sep=&]{
    outcome                                 & Expected & Result \\
    No Attacker: Success                    &    10000 &  10000 \\
    Impersonate Alice: Detected             &     7500 &   7464 \\
    Impersonate Bob: Detected               &     9961 &   9891 \\
    Intercept-and-resend: Detected by Bob   &     7500 &   7441 \\
    Intercept-and-resend: Detected by Alice &     9961 &   9954 \\
    Intercept-and-resend: Detected          &     9990 &   9985 \\
    1-Qubit Modification: Detected by Bob   &     6667 &   6678 \\
    1-Qubit Modification: Detected by Alice &     3333 &   3322 \\
    1-Qubit Modification: Detected          &    10000 &  10000 \\
}\mydata

\begin{figure}
    \vspace{1em}
    \caption{Expected vs. simulated results after 10,000 simulations with $n=16$}
    \label{fig:resultsGraph}
    \vspace{1em}
    \begin{tikzpicture}
        \begin{axis}
            [
                xbar,
                ylabel = {Outcome},
                xlabel = {\# occurrences},
                xlabel style = {
                    yshift = 1em,
                },
                bar shift = {-0.4*(\numplotsofactualtype*\pgfplotbarwidth + (\numplotsofactualtype-1)*(2pt)) - (.5+\plotnumofactualtype)*\pgfplotbarwidth - \plotnumofactualtype*(2pt)},
                symbolic y coords = {
                    No Attacker: Success,
                    Impersonate Alice: Detected,
                    Impersonate Bob: Detected,
                    Intercept-and-resend: Detected by Bob,
                    Intercept-and-resend: Detected by Alice,
                    Intercept-and-resend: Detected,
                    1-Qubit Modification: Detected by Bob,
                    1-Qubit Modification: Detected by Alice,
                    1-Qubit Modification: Detected,
                },
                tick label style = {
                    font = \small,
                },
                y tick label style = {
                    anchor = west,
                    xshift = 0.1cm,
                    yshift = 0,
                },
                y dir = reverse,
                xtick = {0, 10000},
                scaled x ticks = false,
                ytick = data,
                xmin = 0,
                xmax = 10000,
                nodes near coords,
                bar width = .3cm,
                height = 15cm,
                width = 8cm,
                legend style = {
                    at={(0.5, 1)},
                    anchor = north,
                    legend columns = -1,
                },
            ]
            \addplot table[y=outcome, x=Expected]{\mydata};
            \addplot table[y=outcome, x=Result]{\mydata};
            \legend{Expected\,\,\,\,, Result}
        \end{axis}
    \end{tikzpicture}
\end{figure}

\section{Conclusion}

In summary, the current work tested a Matlab with QIT implementation
of the randomization-based ASQDC protocol in five sets of circumstances:
no attacker, impersonation of Alice, impersonation of Bob, intercept-and-resend
attack, and 1-qubit modification attack. The measured results were
then compared against the theoretical values, supporting the claims
of the ASQDC protocol authors.

This is relevant to quantum communications research as such a protocol
may be more feasible than fully-quantum protocols in a variety of
circumstances in the short-to-medium term. Furthermore, it was shown
that the protocol is, in fact, secure against four major categories
of attack.

Future work would include testing the protocol against additional
attacks, such as n-qubit modification attacks. It would also be of
benefit to test the protocol on computers which are capable of handling
larger values of $n$ (longer messages) in order to demonstrate empirically
that the security does in fact scale with message length as predicted
by theory.

\begin{thebibliography}{00}
\bibitem{LuoHwang} Y.-P. Luo, T. Hwang, ``Authenticated semi-quantum direct communication protocols using Bell states,'' Quantum Information Processing, vol. 15, no. 2, pp. 957--958, 2015.
\bibitem{YuEtAl} K. Yu, C.-W. Yang, C.-H. Liao, T. Hwang, ``Authenticated semi-quantum key distribution protocol using Bell states,'' Quantum Information Processing, vol. 13, no. 6, pp. 1457--1565, 2014.
\end{thebibliography}
\vspace{12pt}

\appendix
\section{Matlab Code}
All Matlab code for the project is attached below. The {\ttfamily Execute.m} script was used to generate the simulated results in Fig. \ref{fig:resultsGraph}.
{\ttfamily numExecutions} on line 5 is the number of simulations to run for each type of attack, which can be modified from 10,000.

\onecolumn
\definecolor{MatlabComment}{rgb}{0, 0.6, 0}
\lstset {
    language=Matlab,
    frame=single,
    breaklines=true,
    showstringspaces=false,
    numbers=left,
    basicstyle=\footnotesize\ttfamily,
    commentstyle=\color{MatlabComment},
    keywordstyle=\color{blue},
    stringstyle=\color{magenta},
}
\lstinputlisting[title=Alice.m]{"../Alice.m"}
\lstinputlisting[title=Bob.m]{"../Bob.m"}
\lstinputlisting[title=Eve.m]{"../Eve.m"}
\lstinputlisting[title=Execute.m]{"../Execute.m"}
\lstinputlisting[title=helper.m]{"../helper.m"}
\lstinputlisting[title=utilities.m]{"../utilities.m"}

\end{document}
